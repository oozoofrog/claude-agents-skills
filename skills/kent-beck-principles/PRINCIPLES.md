# 켄트 벡의 핵심 원칙

## 1. TDD (Test-Driven Development)

### Red-Green-Refactor 사이클

```
┌─────────────────────────────────────────────────┐
│                                                 │
│    ┌───────┐      ┌───────┐      ┌──────────┐  │
│    │  RED  │ ───▶ │ GREEN │ ───▶ │ REFACTOR │  │
│    └───────┘      └───────┘      └──────────┘  │
│        ▲                              │        │
│        └──────────────────────────────┘        │
│                                                 │
└─────────────────────────────────────────────────┘
```

#### RED (실패하는 테스트 작성)
- 구현하기 전에 테스트 먼저 작성
- 테스트는 명확한 실패 메시지를 보여야 함
- 한 번에 하나의 기능만 테스트

#### GREEN (최소한의 구현)
- 테스트를 통과하는 가장 단순한 코드 작성
- "완벽한" 코드가 아닌 "작동하는" 코드
- 복잡한 설계는 이 단계에서 하지 않음

#### REFACTOR (개선)
- 중복 제거
- 명확성 개선
- 테스트는 계속 통과해야 함
- 기능 추가 금지 (기능 추가는 새로운 RED부터)

### TDD의 핵심 규칙

1. **실패하는 테스트 없이 프로덕션 코드 작성 금지**
2. **실패를 보여주기에 충분한 만큼만 테스트 작성**
3. **테스트를 통과시키기에 충분한 만큼만 코드 작성**

---

## 2. 단순한 설계의 4가지 규칙

켄트 벡이 정의한 "단순한 설계"의 우선순위:

### 1순위: 테스트 통과
모든 테스트가 통과해야 함. 이것이 가장 기본.

### 2순위: 의도 드러내기
코드를 읽는 사람이 의도를 바로 이해할 수 있어야 함.

```swift
// Bad: 의도가 불명확
func process(_ items: [Int]) -> [Int] {
    items.filter { $0 % 2 == 0 }
}

// Good: 의도가 명확
func filterEvenNumbers(_ numbers: [Int]) -> [Int] {
    numbers.filter { $0.isEven }
}
```

### 3순위: 중복 제거
같은 코드, 같은 로직이 두 번 이상 나타나면 제거.

### 4순위: 최소 요소
위 세 가지를 만족하면서 가장 적은 클래스/메서드/함수 사용.

---

## 3. 리팩토링 원칙

### 행동 보존
> "리팩토링은 외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 것"

- 리팩토링 전후로 테스트 결과가 동일해야 함
- 기능 추가와 리팩토링을 동시에 하지 않음

### 작은 단계
```
큰 변경 = 작은 변경1 + 작은 변경2 + ... + 작은 변경N
```

각 작은 변경 후:
1. 테스트 실행
2. 통과 확인
3. 커밋 (선택적)

### 리팩토링 시점

**리팩토링 해야 할 때:**
- 새 기능 추가 전 (기존 코드가 복잡할 때)
- 버그 수정 전 (버그 원인이 복잡한 코드일 때)
- 코드 리뷰 중 (문제 발견 시)

**리팩토링 하지 말아야 할 때:**
- 마감 직전
- 테스트가 없는 코드 (테스트 먼저 추가)
- 완전히 재작성이 필요한 코드

---

## 4. YAGNI (You Aren't Gonna Need It)

> "실제로 필요할 때까지 기능을 추가하지 마라"

### 적용 예시

```swift
// Bad: 미래를 위한 과도한 추상화
protocol DataSourceProtocol {
    associatedtype Item
    func fetch() async throws -> [Item]
    func cache(_ items: [Item])
    func invalidateCache()
    func prefetch(ids: [String])
    // ... 10개의 더 많은 메서드
}

// Good: 현재 필요한 것만
protocol DataFetching {
    func fetch() async throws -> [Item]
}
```

### YAGNI vs 좋은 설계

YAGNI는 "설계하지 마라"가 아님:
- 현재 요구사항에 대한 좋은 설계는 필수
- 미래의 가상 요구사항을 위한 복잡성은 제거

---

## 5. 점진적 개선

### 보이스카우트 규칙
> "캠프장을 떠날 때는 도착했을 때보다 더 깨끗하게"

코드를 수정할 때:
- 작은 개선 하나씩 추가
- 변수명 개선
- 작은 중복 제거
- 명확성 향상

### 기술 부채 관리

```
기술 부채 = 나쁜 코드를 수정하지 않고 넘어간 비용
이자 = 나쁜 코드로 인해 추가되는 개발 시간
```

부채 상환 전략:
1. 새 기능 추가 시 주변 코드 개선
2. 정기적인 리팩토링 시간 확보
3. 큰 부채는 점진적으로 상환

---

## 6. 코드 커뮤니케이션

### 코드는 문서다

```swift
// 주석이 필요한 코드 = 개선이 필요한 코드

// Bad
// 사용자가 성인인지 확인
if user.age >= 18 { ... }

// Good
if user.isAdult { ... }
```

### 이름 짓기 원칙

1. **의도를 드러내는 이름**
   - `d` → `elapsedTimeInDays`
   - `list` → `activeUsers`

2. **검색 가능한 이름**
   - 한 글자 변수는 지역 변수에만
   - 상수에는 의미 있는 이름

3. **발음 가능한 이름**
   - `genymdhms` → `generationTimestamp`
